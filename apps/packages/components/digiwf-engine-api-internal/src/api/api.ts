/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ConfigEntry
 */
export interface ConfigEntry {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntry
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigEntry
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface FilterDto
 */
export interface FilterDto {
    /**
     * 
     * @type {string}
     * @memberof FilterDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilterDto
     */
    'filterString'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilterDto
     */
    'pageId'?: string;
}
/**
 * 
 * @export
 * @interface HistoryTask
 */
export interface HistoryTask {
    /**
     * 
     * @type {string}
     * @memberof HistoryTask
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoryTask
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoryTask
     */
    'endTime'?: string;
}
/**
 * 
 * @export
 * @interface PageProcessDefinitionDto
 */
export interface PageProcessDefinitionDto {
    /**
     * 
     * @type {number}
     * @memberof PageProcessDefinitionDto
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageProcessDefinitionDto
     */
    'totalPages'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageProcessDefinitionDto
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageProcessDefinitionDto
     */
    'last'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageProcessDefinitionDto
     */
    'size'?: number;
    /**
     * 
     * @type {Array<ProcessDefinitionDto>}
     * @memberof PageProcessDefinitionDto
     */
    'content'?: Array<ProcessDefinitionDto>;
    /**
     * 
     * @type {number}
     * @memberof PageProcessDefinitionDto
     */
    'number'?: number;
    /**
     * 
     * @type {SortObject}
     * @memberof PageProcessDefinitionDto
     */
    'sort'?: SortObject;
    /**
     * 
     * @type {number}
     * @memberof PageProcessDefinitionDto
     */
    'numberOfElements'?: number;
    /**
     * 
     * @type {PageableObject}
     * @memberof PageProcessDefinitionDto
     */
    'pageable'?: PageableObject;
    /**
     * 
     * @type {boolean}
     * @memberof PageProcessDefinitionDto
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface PageableObject
 */
export interface PageableObject {
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'offset'?: number;
    /**
     * 
     * @type {SortObject}
     * @memberof PageableObject
     */
    'sort'?: SortObject;
    /**
     * 
     * @type {boolean}
     * @memberof PageableObject
     */
    'paged'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageableObject
     */
    'unpaged'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'pageNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'pageSize'?: number;
}
/**
 * 
 * @export
 * @interface ProcessConfig
 */
export interface ProcessConfig {
    /**
     * 
     * @type {string}
     * @memberof ProcessConfig
     */
    'statusDokument'?: string;
    /**
     * 
     * @type {Array<StatusConfig>}
     * @memberof ProcessConfig
     */
    'statusConfig'?: Array<StatusConfig>;
    /**
     * 
     * @type {Array<ConfigEntry>}
     * @memberof ProcessConfig
     */
    'configs'?: Array<ConfigEntry>;
    /**
     * 
     * @type {string}
     * @memberof ProcessConfig
     */
    'instanceFilePathsReadonly'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessConfig
     */
    'instanceFilePaths'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessConfig
     */
    'filePathsReadonly'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessConfig
     */
    'filePaths'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessConfig
     */
    'instanceSchemaKey'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProcessConfig
     */
    'ignoreFieldsOnStart'?: boolean;
}
/**
 * 
 * @export
 * @interface ProcessDefinitionDto
 */
export interface ProcessDefinitionDto {
    /**
     * 
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    'versionTag'?: string;
}
/**
 * 
 * @export
 * @interface ProcessDefinitionWithSchemaDto
 */
export interface ProcessDefinitionWithSchemaDto {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ProcessDefinitionWithSchemaDto
     */
    'jsonSchema'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof ProcessDefinitionWithSchemaDto
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessDefinitionWithSchemaDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessDefinitionWithSchemaDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessDefinitionWithSchemaDto
     */
    'versionTag'?: string;
}
/**
 * 
 * @export
 * @interface ProcessInstanceDetailDto
 */
export interface ProcessInstanceDetailDto {
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDetailDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDetailDto
     */
    'definitionName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDetailDto
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDetailDto
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDetailDto
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDetailDto
     */
    'statusKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDetailDto
     */
    'description'?: string;
    /**
     * 
     * @type {ProcessConfig}
     * @memberof ProcessInstanceDetailDto
     */
    'processConfig'?: ProcessConfig;
    /**
     * 
     * @type {Array<HistoryTask>}
     * @memberof ProcessInstanceDetailDto
     */
    'historyTasks'?: Array<HistoryTask>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ProcessInstanceDetailDto
     */
    'data'?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ProcessInstanceDetailDto
     */
    'jsonSchema'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface ProcessInstanceDto
 */
export interface ProcessInstanceDto {
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDto
     */
    'definitionName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDto
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDto
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDto
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface SaveFilterDto
 */
export interface SaveFilterDto {
    /**
     * 
     * @type {string}
     * @memberof SaveFilterDto
     */
    'filterString': string;
    /**
     * 
     * @type {string}
     * @memberof SaveFilterDto
     */
    'pageId': string;
}
/**
 * 
 * @export
 * @interface SearchUserDto
 */
export interface SearchUserDto {
    /**
     * 
     * @type {string}
     * @memberof SearchUserDto
     */
    'searchString'?: string;
}
/**
 * 
 * @export
 * @interface SortObject
 */
export interface SortObject {
    /**
     * 
     * @type {boolean}
     * @memberof SortObject
     */
    'empty'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SortObject
     */
    'sorted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SortObject
     */
    'unsorted'?: boolean;
}
/**
 * 
 * @export
 * @interface StartInstanceDto
 */
export interface StartInstanceDto {
    /**
     * 
     * @type {string}
     * @memberof StartInstanceDto
     */
    'key'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof StartInstanceDto
     */
    'variables'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface StatusConfig
 */
export interface StatusConfig {
    /**
     * 
     * @type {string}
     * @memberof StatusConfig
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusConfig
     */
    'label'?: string;
    /**
     * 
     * @type {number}
     * @memberof StatusConfig
     */
    'position'?: number;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'forename'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'surname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'email'?: string;
}

/**
 * FilterRestControllerApi - axios parameter creator
 * @export
 */
export const FilterRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/rest/filter/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilters: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SaveFilterDto} saveFilterDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveFilter: async (saveFilterDto: SaveFilterDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveFilterDto' is not null or undefined
            assertParamExists('saveFilter', 'saveFilterDto', saveFilterDto)
            const localVarPath = `/rest/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveFilterDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilterRestControllerApi - functional programming interface
 * @export
 */
export const FilterRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilterRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilters(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FilterDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilters(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SaveFilterDto} saveFilterDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveFilter(saveFilterDto: SaveFilterDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilterDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveFilter(saveFilterDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilterRestControllerApi - factory interface
 * @export
 */
export const FilterRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilterRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilters(options?: any): AxiosPromise<Array<FilterDto>> {
            return localVarFp.getFilters(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SaveFilterDto} saveFilterDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveFilter(saveFilterDto: SaveFilterDto, options?: any): AxiosPromise<FilterDto> {
            return localVarFp.saveFilter(saveFilterDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _delete operation in FilterRestControllerApi.
 * @export
 * @interface FilterRestControllerApiDeleteRequest
 */
export interface FilterRestControllerApiDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof FilterRestControllerApiDelete
     */
    readonly id: string
}

/**
 * Request parameters for saveFilter operation in FilterRestControllerApi.
 * @export
 * @interface FilterRestControllerApiSaveFilterRequest
 */
export interface FilterRestControllerApiSaveFilterRequest {
    /**
     * 
     * @type {SaveFilterDto}
     * @memberof FilterRestControllerApiSaveFilter
     */
    readonly saveFilterDto: SaveFilterDto
}

/**
 * FilterRestControllerApi - object-oriented interface
 * @export
 * @class FilterRestControllerApi
 * @extends {BaseAPI}
 */
export class FilterRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {FilterRestControllerApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterRestControllerApi
     */
    public _delete(requestParameters: FilterRestControllerApiDeleteRequest, options?: AxiosRequestConfig) {
        return FilterRestControllerApiFp(this.configuration)._delete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterRestControllerApi
     */
    public getFilters(options?: AxiosRequestConfig) {
        return FilterRestControllerApiFp(this.configuration).getFilters(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FilterRestControllerApiSaveFilterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterRestControllerApi
     */
    public saveFilter(requestParameters: FilterRestControllerApiSaveFilterRequest, options?: AxiosRequestConfig) {
        return FilterRestControllerApiFp(this.configuration).saveFilter(requestParameters.saveFilterDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProcessDefinitionControllerApi - axios parameter creator
 * @export
 */
export const ProcessDefinitionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a specific service definition
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinition: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getProcessDefinition', 'key', key)
            const localVarPath = `/rest/process/definition/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * load all available service definitions
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDefinitions: async (page?: number, size?: number, query?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/process/definition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initialize the start context of a specific process
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initalizeStartContext: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('initalizeStartContext', 'key', key)
            const localVarPath = `/rest/process/definition/context/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a specific service
         * @param {StartInstanceDto} startInstanceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startInstance: async (startInstanceDto: StartInstanceDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startInstanceDto' is not null or undefined
            assertParamExists('startInstance', 'startInstanceDto', startInstanceDto)
            const localVarPath = `/rest/process/definition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startInstanceDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessDefinitionControllerApi - functional programming interface
 * @export
 */
export const ProcessDefinitionControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProcessDefinitionControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a specific service definition
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinition(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessDefinitionWithSchemaDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessDefinition(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * load all available service definitions
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDefinitions(page?: number, size?: number, query?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageProcessDefinitionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDefinitions(page, size, query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initialize the start context of a specific process
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initalizeStartContext(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initalizeStartContext(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Start a specific service
         * @param {StartInstanceDto} startInstanceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startInstance(startInstanceDto: StartInstanceDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startInstance(startInstanceDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProcessDefinitionControllerApi - factory interface
 * @export
 */
export const ProcessDefinitionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProcessDefinitionControllerApiFp(configuration)
    return {
        /**
         * Get a specific service definition
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinition(key: string, options?: any): AxiosPromise<ProcessDefinitionWithSchemaDto> {
            return localVarFp.getProcessDefinition(key, options).then((request) => request(axios, basePath));
        },
        /**
         * load all available service definitions
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDefinitions(page?: number, size?: number, query?: string, options?: any): AxiosPromise<PageProcessDefinitionDto> {
            return localVarFp.getServiceDefinitions(page, size, query, options).then((request) => request(axios, basePath));
        },
        /**
         * Initialize the start context of a specific process
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initalizeStartContext(key: string, options?: any): AxiosPromise<void> {
            return localVarFp.initalizeStartContext(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a specific service
         * @param {StartInstanceDto} startInstanceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startInstance(startInstanceDto: StartInstanceDto, options?: any): AxiosPromise<void> {
            return localVarFp.startInstance(startInstanceDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getProcessDefinition operation in ProcessDefinitionControllerApi.
 * @export
 * @interface ProcessDefinitionControllerApiGetProcessDefinitionRequest
 */
export interface ProcessDefinitionControllerApiGetProcessDefinitionRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessDefinitionControllerApiGetProcessDefinition
     */
    readonly key: string
}

/**
 * Request parameters for getServiceDefinitions operation in ProcessDefinitionControllerApi.
 * @export
 * @interface ProcessDefinitionControllerApiGetServiceDefinitionsRequest
 */
export interface ProcessDefinitionControllerApiGetServiceDefinitionsRequest {
    /**
     * 
     * @type {number}
     * @memberof ProcessDefinitionControllerApiGetServiceDefinitions
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProcessDefinitionControllerApiGetServiceDefinitions
     */
    readonly size?: number

    /**
     * 
     * @type {string}
     * @memberof ProcessDefinitionControllerApiGetServiceDefinitions
     */
    readonly query?: string
}

/**
 * Request parameters for initalizeStartContext operation in ProcessDefinitionControllerApi.
 * @export
 * @interface ProcessDefinitionControllerApiInitalizeStartContextRequest
 */
export interface ProcessDefinitionControllerApiInitalizeStartContextRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessDefinitionControllerApiInitalizeStartContext
     */
    readonly key: string
}

/**
 * Request parameters for startInstance operation in ProcessDefinitionControllerApi.
 * @export
 * @interface ProcessDefinitionControllerApiStartInstanceRequest
 */
export interface ProcessDefinitionControllerApiStartInstanceRequest {
    /**
     * 
     * @type {StartInstanceDto}
     * @memberof ProcessDefinitionControllerApiStartInstance
     */
    readonly startInstanceDto: StartInstanceDto
}

/**
 * ProcessDefinitionControllerApi - object-oriented interface
 * @export
 * @class ProcessDefinitionControllerApi
 * @extends {BaseAPI}
 */
export class ProcessDefinitionControllerApi extends BaseAPI {
    /**
     * Get a specific service definition
     * @param {ProcessDefinitionControllerApiGetProcessDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionControllerApi
     */
    public getProcessDefinition(requestParameters: ProcessDefinitionControllerApiGetProcessDefinitionRequest, options?: AxiosRequestConfig) {
        return ProcessDefinitionControllerApiFp(this.configuration).getProcessDefinition(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * load all available service definitions
     * @param {ProcessDefinitionControllerApiGetServiceDefinitionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionControllerApi
     */
    public getServiceDefinitions(requestParameters: ProcessDefinitionControllerApiGetServiceDefinitionsRequest = {}, options?: AxiosRequestConfig) {
        return ProcessDefinitionControllerApiFp(this.configuration).getServiceDefinitions(requestParameters.page, requestParameters.size, requestParameters.query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initialize the start context of a specific process
     * @param {ProcessDefinitionControllerApiInitalizeStartContextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionControllerApi
     */
    public initalizeStartContext(requestParameters: ProcessDefinitionControllerApiInitalizeStartContextRequest, options?: AxiosRequestConfig) {
        return ProcessDefinitionControllerApiFp(this.configuration).initalizeStartContext(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a specific service
     * @param {ProcessDefinitionControllerApiStartInstanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionControllerApi
     */
    public startInstance(requestParameters: ProcessDefinitionControllerApiStartInstanceRequest, options?: AxiosRequestConfig) {
        return ProcessDefinitionControllerApiFp(this.configuration).startInstance(requestParameters.startInstanceDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProcessInstanceControllerApi - axios parameter creator
 * @export
 */
export const ProcessInstanceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedInstances: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/process/instance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceDetail: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProcessInstanceDetail', 'id', id)
            const localVarPath = `/rest/process/instance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessInstanceControllerApi - functional programming interface
 * @export
 */
export const ProcessInstanceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProcessInstanceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssignedInstances(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProcessInstanceDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssignedInstances(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessInstanceDetail(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessInstanceDetailDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessInstanceDetail(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProcessInstanceControllerApi - factory interface
 * @export
 */
export const ProcessInstanceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProcessInstanceControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedInstances(options?: any): AxiosPromise<Array<ProcessInstanceDto>> {
            return localVarFp.getAssignedInstances(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceDetail(id: string, options?: any): AxiosPromise<ProcessInstanceDetailDto> {
            return localVarFp.getProcessInstanceDetail(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getProcessInstanceDetail operation in ProcessInstanceControllerApi.
 * @export
 * @interface ProcessInstanceControllerApiGetProcessInstanceDetailRequest
 */
export interface ProcessInstanceControllerApiGetProcessInstanceDetailRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceControllerApiGetProcessInstanceDetail
     */
    readonly id: string
}

/**
 * ProcessInstanceControllerApi - object-oriented interface
 * @export
 * @class ProcessInstanceControllerApi
 * @extends {BaseAPI}
 */
export class ProcessInstanceControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceControllerApi
     */
    public getAssignedInstances(options?: AxiosRequestConfig) {
        return ProcessInstanceControllerApiFp(this.configuration).getAssignedInstances(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ProcessInstanceControllerApiGetProcessInstanceDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceControllerApi
     */
    public getProcessInstanceDetail(requestParameters: ProcessInstanceControllerApiGetProcessInstanceDetailRequest, options?: AxiosRequestConfig) {
        return ProcessInstanceControllerApiFp(this.configuration).getProcessInstanceDetail(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceInstanceFileRestControllerApi - axios parameter creator
 * @export
 */
export const ServiceInstanceFileRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames1: async (instanceId: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getFileNames1', 'instanceId', instanceId)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getFileNames1', 'filePath', filePath)
            const localVarPath = `/rest/service/instance/file/{instanceId}`
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion1: async (instanceId: string, filename: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion1', 'instanceId', instanceId)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion1', 'filename', filename)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion1', 'filePath', filePath)
            const localVarPath = `/rest/service/instance/file/{instanceId}/{filename}`
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload1: async (instanceId: string, fileName: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload1', 'instanceId', instanceId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload1', 'fileName', fileName)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload1', 'filePath', filePath)
            const localVarPath = `/rest/service/instance/file/{instanceId}/{fileName}`
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload1: async (instanceId: string, filename: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload1', 'instanceId', instanceId)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload1', 'filename', filename)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload1', 'filePath', filePath)
            const localVarPath = `/rest/service/instance/file/{instanceId}/{filename}`
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceInstanceFileRestControllerApi - functional programming interface
 * @export
 */
export const ServiceInstanceFileRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceInstanceFileRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileNames1(instanceId: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileNames1(instanceId, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDeletion1(instanceId: string, filename: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDeletion1(instanceId, filename, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDownload1(instanceId: string, fileName: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDownload1(instanceId, fileName, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileUpload1(instanceId: string, filename: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileUpload1(instanceId, filename, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceInstanceFileRestControllerApi - factory interface
 * @export
 */
export const ServiceInstanceFileRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceInstanceFileRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames1(instanceId: string, filePath: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getFileNames1(instanceId, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion1(instanceId: string, filename: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDeletion1(instanceId, filename, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload1(instanceId: string, fileName: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDownload1(instanceId, fileName, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload1(instanceId: string, filename: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileUpload1(instanceId, filename, filePath, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFileNames1 operation in ServiceInstanceFileRestControllerApi.
 * @export
 * @interface ServiceInstanceFileRestControllerApiGetFileNames1Request
 */
export interface ServiceInstanceFileRestControllerApiGetFileNames1Request {
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetFileNames1
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetFileNames1
     */
    readonly filePath: string
}

/**
 * Request parameters for getPresignedUrlForFileDeletion1 operation in ServiceInstanceFileRestControllerApi.
 * @export
 * @interface ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDeletion1Request
 */
export interface ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDeletion1Request {
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDeletion1
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDeletion1
     */
    readonly filename: string

    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDeletion1
     */
    readonly filePath: string
}

/**
 * Request parameters for getPresignedUrlForFileDownload1 operation in ServiceInstanceFileRestControllerApi.
 * @export
 * @interface ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDownload1Request
 */
export interface ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDownload1Request {
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDownload1
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDownload1
     */
    readonly fileName: string

    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDownload1
     */
    readonly filePath: string
}

/**
 * Request parameters for getPresignedUrlForFileUpload1 operation in ServiceInstanceFileRestControllerApi.
 * @export
 * @interface ServiceInstanceFileRestControllerApiGetPresignedUrlForFileUpload1Request
 */
export interface ServiceInstanceFileRestControllerApiGetPresignedUrlForFileUpload1Request {
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileUpload1
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileUpload1
     */
    readonly filename: string

    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileUpload1
     */
    readonly filePath: string
}

/**
 * ServiceInstanceFileRestControllerApi - object-oriented interface
 * @export
 * @class ServiceInstanceFileRestControllerApi
 * @extends {BaseAPI}
 */
export class ServiceInstanceFileRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {ServiceInstanceFileRestControllerApiGetFileNames1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceFileRestControllerApi
     */
    public getFileNames1(requestParameters: ServiceInstanceFileRestControllerApiGetFileNames1Request, options?: AxiosRequestConfig) {
        return ServiceInstanceFileRestControllerApiFp(this.configuration).getFileNames1(requestParameters.instanceId, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDeletion1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceFileRestControllerApi
     */
    public getPresignedUrlForFileDeletion1(requestParameters: ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDeletion1Request, options?: AxiosRequestConfig) {
        return ServiceInstanceFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDeletion1(requestParameters.instanceId, requestParameters.filename, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDownload1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceFileRestControllerApi
     */
    public getPresignedUrlForFileDownload1(requestParameters: ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDownload1Request, options?: AxiosRequestConfig) {
        return ServiceInstanceFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDownload1(requestParameters.instanceId, requestParameters.fileName, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServiceInstanceFileRestControllerApiGetPresignedUrlForFileUpload1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceFileRestControllerApi
     */
    public getPresignedUrlForFileUpload1(requestParameters: ServiceInstanceFileRestControllerApiGetPresignedUrlForFileUpload1Request, options?: AxiosRequestConfig) {
        return ServiceInstanceFileRestControllerApiFp(this.configuration).getPresignedUrlForFileUpload1(requestParameters.instanceId, requestParameters.filename, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceStartFileRestControllerApi - axios parameter creator
 * @export
 */
export const ServiceStartFileRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames: async (definitionKey: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'definitionKey' is not null or undefined
            assertParamExists('getFileNames', 'definitionKey', definitionKey)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getFileNames', 'filePath', filePath)
            const localVarPath = `/rest/service/start/file/{definitionKey}`
                .replace(`{${"definitionKey"}}`, encodeURIComponent(String(definitionKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion: async (definitionKey: string, filename: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'definitionKey' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion', 'definitionKey', definitionKey)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion', 'filename', filename)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion', 'filePath', filePath)
            const localVarPath = `/rest/service/start/file/{definitionKey}/{filename}`
                .replace(`{${"definitionKey"}}`, encodeURIComponent(String(definitionKey)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload: async (definitionKey: string, fileName: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'definitionKey' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload', 'definitionKey', definitionKey)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload', 'fileName', fileName)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload', 'filePath', filePath)
            const localVarPath = `/rest/service/start/file/{definitionKey}/{fileName}`
                .replace(`{${"definitionKey"}}`, encodeURIComponent(String(definitionKey)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload: async (definitionKey: string, filename: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'definitionKey' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload', 'definitionKey', definitionKey)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload', 'filename', filename)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload', 'filePath', filePath)
            const localVarPath = `/rest/service/start/file/{definitionKey}/{filename}`
                .replace(`{${"definitionKey"}}`, encodeURIComponent(String(definitionKey)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceStartFileRestControllerApi - functional programming interface
 * @export
 */
export const ServiceStartFileRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceStartFileRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileNames(definitionKey: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileNames(definitionKey, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDeletion(definitionKey: string, filename: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDeletion(definitionKey, filename, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDownload(definitionKey: string, fileName: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDownload(definitionKey, fileName, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileUpload(definitionKey: string, filename: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileUpload(definitionKey, filename, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceStartFileRestControllerApi - factory interface
 * @export
 */
export const ServiceStartFileRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceStartFileRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames(definitionKey: string, filePath: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getFileNames(definitionKey, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion(definitionKey: string, filename: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDeletion(definitionKey, filename, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload(definitionKey: string, fileName: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDownload(definitionKey, fileName, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload(definitionKey: string, filename: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileUpload(definitionKey, filename, filePath, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFileNames operation in ServiceStartFileRestControllerApi.
 * @export
 * @interface ServiceStartFileRestControllerApiGetFileNamesRequest
 */
export interface ServiceStartFileRestControllerApiGetFileNamesRequest {
    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetFileNames
     */
    readonly definitionKey: string

    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetFileNames
     */
    readonly filePath: string
}

/**
 * Request parameters for getPresignedUrlForFileDeletion operation in ServiceStartFileRestControllerApi.
 * @export
 * @interface ServiceStartFileRestControllerApiGetPresignedUrlForFileDeletionRequest
 */
export interface ServiceStartFileRestControllerApiGetPresignedUrlForFileDeletionRequest {
    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileDeletion
     */
    readonly definitionKey: string

    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileDeletion
     */
    readonly filename: string

    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileDeletion
     */
    readonly filePath: string
}

/**
 * Request parameters for getPresignedUrlForFileDownload operation in ServiceStartFileRestControllerApi.
 * @export
 * @interface ServiceStartFileRestControllerApiGetPresignedUrlForFileDownloadRequest
 */
export interface ServiceStartFileRestControllerApiGetPresignedUrlForFileDownloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileDownload
     */
    readonly definitionKey: string

    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileDownload
     */
    readonly fileName: string

    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileDownload
     */
    readonly filePath: string
}

/**
 * Request parameters for getPresignedUrlForFileUpload operation in ServiceStartFileRestControllerApi.
 * @export
 * @interface ServiceStartFileRestControllerApiGetPresignedUrlForFileUploadRequest
 */
export interface ServiceStartFileRestControllerApiGetPresignedUrlForFileUploadRequest {
    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileUpload
     */
    readonly definitionKey: string

    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileUpload
     */
    readonly filename: string

    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileUpload
     */
    readonly filePath: string
}

/**
 * ServiceStartFileRestControllerApi - object-oriented interface
 * @export
 * @class ServiceStartFileRestControllerApi
 * @extends {BaseAPI}
 */
export class ServiceStartFileRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {ServiceStartFileRestControllerApiGetFileNamesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceStartFileRestControllerApi
     */
    public getFileNames(requestParameters: ServiceStartFileRestControllerApiGetFileNamesRequest, options?: AxiosRequestConfig) {
        return ServiceStartFileRestControllerApiFp(this.configuration).getFileNames(requestParameters.definitionKey, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServiceStartFileRestControllerApiGetPresignedUrlForFileDeletionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceStartFileRestControllerApi
     */
    public getPresignedUrlForFileDeletion(requestParameters: ServiceStartFileRestControllerApiGetPresignedUrlForFileDeletionRequest, options?: AxiosRequestConfig) {
        return ServiceStartFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDeletion(requestParameters.definitionKey, requestParameters.filename, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServiceStartFileRestControllerApiGetPresignedUrlForFileDownloadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceStartFileRestControllerApi
     */
    public getPresignedUrlForFileDownload(requestParameters: ServiceStartFileRestControllerApiGetPresignedUrlForFileDownloadRequest, options?: AxiosRequestConfig) {
        return ServiceStartFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDownload(requestParameters.definitionKey, requestParameters.fileName, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServiceStartFileRestControllerApiGetPresignedUrlForFileUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceStartFileRestControllerApi
     */
    public getPresignedUrlForFileUpload(requestParameters: ServiceStartFileRestControllerApiGetPresignedUrlForFileUploadRequest, options?: AxiosRequestConfig) {
        return ServiceStartFileRestControllerApiFp(this.configuration).getPresignedUrlForFileUpload(requestParameters.definitionKey, requestParameters.filename, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/rest/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserByUsername', 'username', username)
            const localVarPath = `/rest/user/uid/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchUserDto} searchUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (searchUserDto: SearchUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchUserDto' is not null or undefined
            assertParamExists('getUsers', 'searchUserDto', searchUserDto)
            const localVarPath = `/rest/user/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/user/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByUsername(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByUsername(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SearchUserDto} searchUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(searchUserDto: SearchUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(searchUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userinfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userinfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<UserDto> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername(username: string, options?: any): AxiosPromise<UserDto> {
            return localVarFp.getUserByUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchUserDto} searchUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(searchUserDto: SearchUserDto, options?: any): AxiosPromise<Array<UserDto>> {
            return localVarFp.getUsers(searchUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfo(options?: any): AxiosPromise<UserDto> {
            return localVarFp.userinfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getUser operation in UserControllerApi.
 * @export
 * @interface UserControllerApiGetUserRequest
 */
export interface UserControllerApiGetUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserControllerApiGetUser
     */
    readonly id: string
}

/**
 * Request parameters for getUserByUsername operation in UserControllerApi.
 * @export
 * @interface UserControllerApiGetUserByUsernameRequest
 */
export interface UserControllerApiGetUserByUsernameRequest {
    /**
     * 
     * @type {string}
     * @memberof UserControllerApiGetUserByUsername
     */
    readonly username: string
}

/**
 * Request parameters for getUsers operation in UserControllerApi.
 * @export
 * @interface UserControllerApiGetUsersRequest
 */
export interface UserControllerApiGetUsersRequest {
    /**
     * 
     * @type {SearchUserDto}
     * @memberof UserControllerApiGetUsers
     */
    readonly searchUserDto: SearchUserDto
}

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @param {UserControllerApiGetUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUser(requestParameters: UserControllerApiGetUserRequest, options?: AxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getUser(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserControllerApiGetUserByUsernameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUserByUsername(requestParameters: UserControllerApiGetUserByUsernameRequest, options?: AxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getUserByUsername(requestParameters.username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserControllerApiGetUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUsers(requestParameters: UserControllerApiGetUsersRequest, options?: AxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getUsers(requestParameters.searchUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public userinfo(options?: AxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).userinfo(options).then((request) => request(this.axios, this.basePath));
    }
}


