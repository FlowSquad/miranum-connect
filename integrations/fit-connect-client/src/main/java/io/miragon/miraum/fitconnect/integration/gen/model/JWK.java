/*
 * Submission API für Antragsverfahren und Berichtspflichten
 * Die FIT-Connect Submission API ermöglicht das Einreichen von Anträgen und Berichten aus vorgelagerten Systemen (z. B. Onlineantragsdiensten, Fachportalen oder Berichtssystemen) an die Systeme der Verwaltung zur elektronischen Verfahrensbearbeitung (z. B. Fachverfahren, Dokumentenmanagementsysteme oder Prozessplattformen). 
 *
 * The version of the OpenAPI document: 1.1.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.miragon.miraum.fitconnect.integration.gen.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * JSON Web Key - RFC 7517
 */
@ApiModel(description = "JSON Web Key - RFC 7517")
@JsonPropertyOrder({
  JWK.JSON_PROPERTY_KTY,
  JWK.JSON_PROPERTY_KEY_OPS,
  JWK.JSON_PROPERTY_ALG,
  JWK.JSON_PROPERTY_X5C,
  JWK.JSON_PROPERTY_KID,
  JWK.JSON_PROPERTY_N,
  JWK.JSON_PROPERTY_E
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class JWK {
  /**
   * Der Parameter \&quot;kty\&quot; (Schlüsseltyp) identifiziert die kryptografische Algorithmus Familie, die mit dem Schlüssel verwendet wird, z. B. \&quot;RSA\&quot; oder \&quot;EC\&quot;. In FIT-Connect sind aktuell nur RSA-Schlüssel erlaubt. 
   */
  public enum KtyEnum {
    RSA("RSA");

    private String value;

    KtyEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static KtyEnum fromValue(String value) {
      for (KtyEnum b : KtyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_KTY = "kty";
  private KtyEnum kty;

  /**
   * Gets or Sets keyOps
   */
  public enum KeyOpsEnum {
    VERIFY("verify"),
    
    WRAPKEY("wrapKey");

    private String value;

    KeyOpsEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static KeyOpsEnum fromValue(String value) {
      for (KeyOpsEnum b : KeyOpsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_KEY_OPS = "key_ops";
  private List<KeyOpsEnum> keyOps = new ArrayList<>();

  /**
   * Der Parameter \&quot;alg\&quot; (Algorithmus) identifiziert den Algorithmus, der für Verwendung mit dem Schlüssel vorgesehen ist. In FIT-Connect wird &#x60;PS512&#x60; für Signaturschlüssel und &#x60;RSA-OAEP-256&#x60; für Verschlüsselungsschlüssel genutzt. 
   */
  public enum AlgEnum {
    PS512("PS512"),
    
    RSA_OAEP_256("RSA-OAEP-256");

    private String value;

    AlgEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static AlgEnum fromValue(String value) {
      for (AlgEnum b : AlgEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_ALG = "alg";
  private AlgEnum alg;

  public static final String JSON_PROPERTY_X5C = "x5c";
  private List<String> x5c = new ArrayList<>();

  public static final String JSON_PROPERTY_KID = "kid";
  private String kid;

  public static final String JSON_PROPERTY_N = "n";
  private String n;

  /**
   * Öffentliche Exponent des Schlüssels
   */
  public enum EEnum {
    AQAB("AQAB");

    private String value;

    EEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static EEnum fromValue(String value) {
      for (EEnum b : EEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_E = "e";
  private EEnum e;

  public JWK() {
  }

  public JWK kty(KtyEnum kty) {
    
    this.kty = kty;
    return this;
  }

   /**
   * Der Parameter \&quot;kty\&quot; (Schlüsseltyp) identifiziert die kryptografische Algorithmus Familie, die mit dem Schlüssel verwendet wird, z. B. \&quot;RSA\&quot; oder \&quot;EC\&quot;. In FIT-Connect sind aktuell nur RSA-Schlüssel erlaubt. 
   * @return kty
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Der Parameter \"kty\" (Schlüsseltyp) identifiziert die kryptografische Algorithmus Familie, die mit dem Schlüssel verwendet wird, z. B. \"RSA\" oder \"EC\". In FIT-Connect sind aktuell nur RSA-Schlüssel erlaubt. ")
  @JsonProperty(JSON_PROPERTY_KTY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public KtyEnum getKty() {
    return kty;
  }


  @JsonProperty(JSON_PROPERTY_KTY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setKty(KtyEnum kty) {
    this.kty = kty;
  }


  public JWK keyOps(List<KeyOpsEnum> keyOps) {
    
    this.keyOps = keyOps;
    return this;
  }

  public JWK addKeyOpsItem(KeyOpsEnum keyOpsItem) {
    this.keyOps.add(keyOpsItem);
    return this;
  }

   /**
   * Der Parameter \&quot;key_ops\&quot; (Schlüsseloperationen) identifiziert die Operation(en) für die der Schlüssel verwendet werden soll. Die Bedeutung der Erlaubten Operationen sind:   - &#x60;verify&#x60;: Digitale Signatur oder MAC überprüfen   - &#x60;wrapKey&#x60;: Verschlüsselungsschlüssel 
   * @return keyOps
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Der Parameter \"key_ops\" (Schlüsseloperationen) identifiziert die Operation(en) für die der Schlüssel verwendet werden soll. Die Bedeutung der Erlaubten Operationen sind:   - `verify`: Digitale Signatur oder MAC überprüfen   - `wrapKey`: Verschlüsselungsschlüssel ")
  @JsonProperty(JSON_PROPERTY_KEY_OPS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<KeyOpsEnum> getKeyOps() {
    return keyOps;
  }


  @JsonProperty(JSON_PROPERTY_KEY_OPS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setKeyOps(List<KeyOpsEnum> keyOps) {
    this.keyOps = keyOps;
  }


  public JWK alg(AlgEnum alg) {
    
    this.alg = alg;
    return this;
  }

   /**
   * Der Parameter \&quot;alg\&quot; (Algorithmus) identifiziert den Algorithmus, der für Verwendung mit dem Schlüssel vorgesehen ist. In FIT-Connect wird &#x60;PS512&#x60; für Signaturschlüssel und &#x60;RSA-OAEP-256&#x60; für Verschlüsselungsschlüssel genutzt. 
   * @return alg
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Der Parameter \"alg\" (Algorithmus) identifiziert den Algorithmus, der für Verwendung mit dem Schlüssel vorgesehen ist. In FIT-Connect wird `PS512` für Signaturschlüssel und `RSA-OAEP-256` für Verschlüsselungsschlüssel genutzt. ")
  @JsonProperty(JSON_PROPERTY_ALG)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public AlgEnum getAlg() {
    return alg;
  }


  @JsonProperty(JSON_PROPERTY_ALG)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setAlg(AlgEnum alg) {
    this.alg = alg;
  }


  public JWK x5c(List<String> x5c) {
    
    this.x5c = x5c;
    return this;
  }

  public JWK addX5cItem(String x5cItem) {
    this.x5c.add(x5cItem);
    return this;
  }

   /**
   * Der Parameter \&quot;x5c\&quot; (X.509 certificate chain) enthält eine Kette von einem oder mehreren PKIX-Zertifikaten [RFC5280]. Die Zertifikatskette wird als JSON-Array von Zertifikatswert-Strings dargestellt. 
   * @return x5c
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Der Parameter \"x5c\" (X.509 certificate chain) enthält eine Kette von einem oder mehreren PKIX-Zertifikaten [RFC5280]. Die Zertifikatskette wird als JSON-Array von Zertifikatswert-Strings dargestellt. ")
  @JsonProperty(JSON_PROPERTY_X5C)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<String> getX5c() {
    return x5c;
  }


  @JsonProperty(JSON_PROPERTY_X5C)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setX5c(List<String> x5c) {
    this.x5c = x5c;
  }


  public JWK kid(String kid) {
    
    this.kid = kid;
    return this;
  }

   /**
   * Der Parameter \&quot;kid\&quot; (Schlüssel-Id) wird verwendet, um einen bestimmten Schlüssel zu finden. Dieser wird z. B. verwendet, um zwischen einer Reihe von Schlüsseln innerhalb eines JWK-Sets zu wählen während des Schlüssel-Rollover. 
   * @return kid
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Der Parameter \"kid\" (Schlüssel-Id) wird verwendet, um einen bestimmten Schlüssel zu finden. Dieser wird z. B. verwendet, um zwischen einer Reihe von Schlüsseln innerhalb eines JWK-Sets zu wählen während des Schlüssel-Rollover. ")
  @JsonProperty(JSON_PROPERTY_KID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getKid() {
    return kid;
  }


  @JsonProperty(JSON_PROPERTY_KID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setKid(String kid) {
    this.kid = kid;
  }


  public JWK n(String n) {
    
    this.n = n;
    return this;
  }

   /**
   * Modulus des Schlüssels. Die minimale Länge von 683 Zeichen repräsentiert eine Schlüssellange von mindestens 4096 Bit.
   * @return n
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Modulus des Schlüssels. Die minimale Länge von 683 Zeichen repräsentiert eine Schlüssellange von mindestens 4096 Bit.")
  @JsonProperty(JSON_PROPERTY_N)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getN() {
    return n;
  }


  @JsonProperty(JSON_PROPERTY_N)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setN(String n) {
    this.n = n;
  }


  public JWK e(EEnum e) {
    
    this.e = e;
    return this;
  }

   /**
   * Öffentliche Exponent des Schlüssels
   * @return e
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Öffentliche Exponent des Schlüssels")
  @JsonProperty(JSON_PROPERTY_E)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public EEnum getE() {
    return e;
  }


  @JsonProperty(JSON_PROPERTY_E)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setE(EEnum e) {
    this.e = e;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    JWK JWK = (JWK) o;
    return Objects.equals(this.kty, JWK.kty) &&
        Objects.equals(this.keyOps, JWK.keyOps) &&
        Objects.equals(this.alg, JWK.alg) &&
        Objects.equals(this.x5c, JWK.x5c) &&
        Objects.equals(this.kid, JWK.kid) &&
        Objects.equals(this.n, JWK.n) &&
        Objects.equals(this.e, JWK.e);
  }

  @Override
  public int hashCode() {
    return Objects.hash(kty, keyOps, alg, x5c, kid, n, e);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class JWK {\n");
    sb.append("    kty: ").append(toIndentedString(kty)).append("\n");
    sb.append("    keyOps: ").append(toIndentedString(keyOps)).append("\n");
    sb.append("    alg: ").append(toIndentedString(alg)).append("\n");
    sb.append("    x5c: ").append(toIndentedString(x5c)).append("\n");
    sb.append("    kid: ").append(toIndentedString(kid)).append("\n");
    sb.append("    n: ").append(toIndentedString(n)).append("\n");
    sb.append("    e: ").append(toIndentedString(e)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

